[1 of 1] Compiling BloomFilter.Hash ( src/BloomFilter/Hash.hs, src/BloomFilter/Hash.o )

ORIGINAL CODE OF doubleHash:

doubleHash :: Hashable a => Int -> a -> [Word32]
doubleHash numHashes value =
  [h1 + h2 * i | i <- [0..num]]
  where
    h =
      hashSalt 0x9150a946c4a8966e value

    h1 =
      fromIntegral (h `shiftR` 32) .&. maxBound

    h2 =
      fromIntegral h

    num =
      fromIntegral numHashes

==================== Tidy Core ====================
Result size of Tidy Core = {terms: 859, types: 980, coercions: 97}

-- RHS size: {terms: 3, types: 4, coercions: 2}
hashSalt [InlPrag=INLINE]
  :: forall a_a2BN[sk].
     Hashable a_a2BN[sk] =>
     Salt -> a_a2BN[sk] -> Word64
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType <S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= \ (@ a_a2BN[sk])
                 (tpl_B1 [Occ=Once] :: Hashable a_a2BN[sk]) ->
                 tpl_B1
                 `cast` (BloomFilter.Hash.N:Hashable[0] <a_a2BN[sk]>_N
                         :: (Hashable a_a2BN[sk] :: Constraint)
                            ~R#
                            ((Salt -> a_a2BN[sk] -> Word64) :: *))}]
hashSalt =
  \ (@ a_a2BN[sk]) (tpl_B1 :: Hashable a_a2BN[sk]) ->
    tpl_B1
    `cast` (BloomFilter.Hash.N:Hashable[0] <a_a2BN[sk]>_N
            :: (Hashable a_a2BN[sk] :: Constraint)
               ~R#
               ((Salt -> a_a2BN[sk] -> Word64) :: *))

-- RHS size: {terms: 2, types: 0, coercions: 0}
BloomFilter.Hash.hash1 :: Word64
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
BloomFilter.Hash.hash1 = GHC.Word.W64# 503340467227682003##

-- RHS size: {terms: 4, types: 4, coercions: 2}
hash :: forall a_a2Ru. Hashable a_a2Ru => a_a2Ru -> Word64
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType <C(S),1*C1(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4Dm)
                 ($dHashable_a5id [Occ=Once] :: Hashable a_a4Dm) ->
                 ($dHashable_a5id
                  `cast` (BloomFilter.Hash.N:Hashable[0] <a_a4Dm>_N
                          :: (Hashable a_a4Dm :: Constraint)
                             ~R#
                             ((Salt -> a_a4Dm -> Word64) :: *)))
                   BloomFilter.Hash.hash1}]
hash =
  \ (@ a_a4Dm) ($dHashable_a5id :: Hashable a_a4Dm) ->
    ($dHashable_a5id
     `cast` (BloomFilter.Hash.N:Hashable[0] <a_a4Dm>_N
             :: (Hashable a_a4Dm :: Constraint)
                ~R#
                ((Salt -> a_a4Dm -> Word64) :: *)))
      BloomFilter.Hash.hash1

-- RHS size: {terms: 18, types: 24, coercions: 6}
BloomFilter.Hash.$fHashable(,,)_$chashSalt
  :: forall a_a5r5 b_a5r6 c_a5r7.
     (Hashable a_a5r5, Hashable b_a5r6, Hashable c_a5r7) =>
     Salt -> (a_a5r5, b_a5r6, c_a5r7) -> Word64
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=DmdType <L,1*C1(C1(U))><L,1*C1(C1(U))><C(C(S)),1*C1(C1(U(U)))><L,U><S,1*U(U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5r5)
                 (@ b_a5r6)
                 (@ c_a5r7)
                 ($dHashable_a5r8 [Occ=Once] :: Hashable a_a5r5)
                 ($dHashable1_a5r9 [Occ=Once] :: Hashable b_a5r6)
                 ($dHashable2_a5ra [Occ=Once] :: Hashable c_a5r7)
                 (salt_a4tL [Occ=Once] :: Salt)
                 (ds_d5tD [Occ=Once!] :: (a_a5r5, b_a5r6, c_a5r7)) ->
                 case ds_d5tD
                 of _ [Occ=Dead]
                 { (a1_a4tM [Occ=Once], b1_a4tN [Occ=Once], c1_a4tO [Occ=Once]) ->
                 ($dHashable2_a5ra
                  `cast` (BloomFilter.Hash.N:Hashable[0] <c_a5r7>_N
                          :: (Hashable c_a5r7 :: Constraint)
                             ~R#
                             ((Salt -> c_a5r7 -> Word64) :: *)))
                   (($dHashable1_a5r9
                     `cast` (BloomFilter.Hash.N:Hashable[0] <b_a5r6>_N
                             :: (Hashable b_a5r6 :: Constraint)
                                ~R#
                                ((Salt -> b_a5r6 -> Word64) :: *)))
                      (($dHashable_a5r8
                        `cast` (BloomFilter.Hash.N:Hashable[0] <a_a5r5>_N
                                :: (Hashable a_a5r5 :: Constraint)
                                   ~R#
                                   ((Salt -> a_a5r5 -> Word64) :: *)))
                         salt_a4tL a1_a4tM)
                      b1_a4tN)
                   c1_a4tO
                 }}]
BloomFilter.Hash.$fHashable(,,)_$chashSalt =
  \ (@ a_a5r5)
    (@ b_a5r6)
    (@ c_a5r7)
    ($dHashable_a5r8 :: Hashable a_a5r5)
    ($dHashable1_a5r9 :: Hashable b_a5r6)
    ($dHashable2_a5ra :: Hashable c_a5r7)
    (salt_a4tL :: Salt)
    (ds_d5tD :: (a_a5r5, b_a5r6, c_a5r7)) ->
    case ds_d5tD of _ [Occ=Dead] { (a1_a4tM, b1_a4tN, c1_a4tO) ->
    ($dHashable2_a5ra
     `cast` (BloomFilter.Hash.N:Hashable[0] <c_a5r7>_N
             :: (Hashable c_a5r7 :: Constraint)
                ~R#
                ((Salt -> c_a5r7 -> Word64) :: *)))
      (($dHashable1_a5r9
        `cast` (BloomFilter.Hash.N:Hashable[0] <b_a5r6>_N
                :: (Hashable b_a5r6 :: Constraint)
                   ~R#
                   ((Salt -> b_a5r6 -> Word64) :: *)))
         (($dHashable_a5r8
           `cast` (BloomFilter.Hash.N:Hashable[0] <a_a5r5>_N
                   :: (Hashable a_a5r5 :: Constraint)
                      ~R#
                      ((Salt -> a_a5r5 -> Word64) :: *)))
            salt_a4tL a1_a4tM)
         b1_a4tN)
      c1_a4tO
    }

-- RHS size: {terms: 1, types: 0, coercions: 24}
BloomFilter.Hash.$fHashable(,,) [InlPrag=INLINE (sat-args=0)]
  :: forall a_a4AU b_a4AV c_a4AW.
     (Hashable a_a4AU, Hashable b_a4AV, Hashable c_a4AW) =>
     Hashable (a_a4AU, b_a4AV, c_a4AW)
[GblId[DFunId(nt)],
 Arity=5,
 Caf=NoCafRefs,
 Str=DmdType <L,1*C1(C1(U))><L,1*C1(C1(U))><C(C(S)),1*C1(C1(U(U)))><L,U><S,1*U(U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=False,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashable(,,)_$chashSalt
               `cast` (forall (a_a5r5 :: <*>_N).
                       forall (b_a5r6 :: <*>_N).
                       forall (c_a5r7 :: <*>_N).
                       <Hashable a_a5r5>_R
                       -> <Hashable b_a5r6>_R
                       -> <Hashable c_a5r7>_R
                       -> Sym
                            (BloomFilter.Hash.N:Hashable[0] <(a_a5r5, b_a5r6, c_a5r7)>_N)
                       :: ((forall a_a5r5 b_a5r6 c_a5r7.
                            (Hashable a_a5r5, Hashable b_a5r6, Hashable c_a5r7) =>
                            Salt -> (a_a5r5, b_a5r6, c_a5r7) -> Word64) :: *)
                          ~R#
                          ((forall a_a5r5 b_a5r6 c_a5r7.
                            (Hashable a_a5r5, Hashable b_a5r6, Hashable c_a5r7) =>
                            Hashable (a_a5r5, b_a5r6, c_a5r7)) :: *))}]
BloomFilter.Hash.$fHashable(,,) =
  BloomFilter.Hash.$fHashable(,,)_$chashSalt
  `cast` (forall (a_a5r5 :: <*>_N).
          forall (b_a5r6 :: <*>_N).
          forall (c_a5r7 :: <*>_N).
          <Hashable a_a5r5>_R
          -> <Hashable b_a5r6>_R
          -> <Hashable c_a5r7>_R
          -> Sym
               (BloomFilter.Hash.N:Hashable[0] <(a_a5r5, b_a5r6, c_a5r7)>_N)
          :: ((forall a_a5r5 b_a5r6 c_a5r7.
               (Hashable a_a5r5, Hashable b_a5r6, Hashable c_a5r7) =>
               Salt -> (a_a5r5, b_a5r6, c_a5r7) -> Word64) :: *)
             ~R#
             ((forall a_a5r5 b_a5r6 c_a5r7.
               (Hashable a_a5r5, Hashable b_a5r6, Hashable c_a5r7) =>
               Hashable (a_a5r5, b_a5r6, c_a5r7)) :: *))

-- RHS size: {terms: 14, types: 17, coercions: 4}
BloomFilter.Hash.$fHashable(,)_$chashSalt
  :: forall a_a5rv b_a5rw.
     (Hashable a_a5rv, Hashable b_a5rw) =>
     Salt -> (a_a5rv, b_a5rw) -> Word64
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=DmdType <L,1*C1(C1(U))><C(C(S)),1*C1(C1(U(U)))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a5rv)
                 (@ b_a5rw)
                 ($dHashable_a5rx [Occ=Once] :: Hashable a_a5rv)
                 ($dHashable1_a5ry [Occ=Once] :: Hashable b_a5rw)
                 (salt_a4tR [Occ=Once] :: Salt)
                 (ds_d5tJ [Occ=Once!] :: (a_a5rv, b_a5rw)) ->
                 case ds_d5tJ
                 of _ [Occ=Dead] { (a1_a4tS [Occ=Once], b1_a4tT [Occ=Once]) ->
                 ($dHashable1_a5ry
                  `cast` (BloomFilter.Hash.N:Hashable[0] <b_a5rw>_N
                          :: (Hashable b_a5rw :: Constraint)
                             ~R#
                             ((Salt -> b_a5rw -> Word64) :: *)))
                   (($dHashable_a5rx
                     `cast` (BloomFilter.Hash.N:Hashable[0] <a_a5rv>_N
                             :: (Hashable a_a5rv :: Constraint)
                                ~R#
                                ((Salt -> a_a5rv -> Word64) :: *)))
                      salt_a4tR a1_a4tS)
                   b1_a4tT
                 }}]
BloomFilter.Hash.$fHashable(,)_$chashSalt =
  \ (@ a_a5rv)
    (@ b_a5rw)
    ($dHashable_a5rx :: Hashable a_a5rv)
    ($dHashable1_a5ry :: Hashable b_a5rw)
    (salt_a4tR :: Salt)
    (ds_d5tJ :: (a_a5rv, b_a5rw)) ->
    case ds_d5tJ of _ [Occ=Dead] { (a1_a4tS, b1_a4tT) ->
    ($dHashable1_a5ry
     `cast` (BloomFilter.Hash.N:Hashable[0] <b_a5rw>_N
             :: (Hashable b_a5rw :: Constraint)
                ~R#
                ((Salt -> b_a5rw -> Word64) :: *)))
      (($dHashable_a5rx
        `cast` (BloomFilter.Hash.N:Hashable[0] <a_a5rv>_N
                :: (Hashable a_a5rv :: Constraint)
                   ~R#
                   ((Salt -> a_a5rv -> Word64) :: *)))
         salt_a4tR a1_a4tS)
      b1_a4tT
    }

-- RHS size: {terms: 1, types: 0, coercions: 17}
BloomFilter.Hash.$fHashable(,) [InlPrag=INLINE (sat-args=0)]
  :: forall a_a4B0 b_a4B1.
     (Hashable a_a4B0, Hashable b_a4B1) =>
     Hashable (a_a4B0, b_a4B1)
[GblId[DFunId(nt)],
 Arity=4,
 Caf=NoCafRefs,
 Str=DmdType <L,1*C1(C1(U))><C(C(S)),1*C1(C1(U(U)))><L,U><S,1*U(U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=False,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashable(,)_$chashSalt
               `cast` (forall (a_a5rv :: <*>_N).
                       forall (b_a5rw :: <*>_N).
                       <Hashable a_a5rv>_R
                       -> <Hashable b_a5rw>_R
                       -> Sym (BloomFilter.Hash.N:Hashable[0] <(a_a5rv, b_a5rw)>_N)
                       :: ((forall a_a5rv b_a5rw.
                            (Hashable a_a5rv, Hashable b_a5rw) =>
                            Salt -> (a_a5rv, b_a5rw) -> Word64) :: *)
                          ~R#
                          ((forall a_a5rv b_a5rw.
                            (Hashable a_a5rv, Hashable b_a5rw) =>
                            Hashable (a_a5rv, b_a5rw)) :: *))}]
BloomFilter.Hash.$fHashable(,) =
  BloomFilter.Hash.$fHashable(,)_$chashSalt
  `cast` (forall (a_a5rv :: <*>_N).
          forall (b_a5rw :: <*>_N).
          <Hashable a_a5rv>_R
          -> <Hashable b_a5rw>_R
          -> Sym (BloomFilter.Hash.N:Hashable[0] <(a_a5rv, b_a5rw)>_N)
          :: ((forall a_a5rv b_a5rw.
               (Hashable a_a5rv, Hashable b_a5rw) =>
               Salt -> (a_a5rv, b_a5rw) -> Word64) :: *)
             ~R#
             ((forall a_a5rv b_a5rw.
               (Hashable a_a5rv, Hashable b_a5rw) =>
               Hashable (a_a5rv, b_a5rw)) :: *))

Rec {
-- RHS size: {terms: 27, types: 31, coercions: 0}
rechunk [Occ=LoopBreaker] :: Lazy.ByteString -> [Strict.ByteString]
[GblId, Arity=1, Str=DmdType <S,1*U>]
rechunk =
  \ (s_a4m1 :: Lazy.ByteString) ->
    case s_a4m1 of wild_a5yn {
      Data.ByteString.Lazy.Internal.Empty ->
        GHC.Types.[] @ Strict.ByteString;
      Data.ByteString.Lazy.Internal.Chunk ipv_a5KA ipv1_a5KB ipv2_a5KC
                                          ipv3_a5KD ipv4_a5KE ->
        let {
          ds_s5K2 [Dmd=<L,U(U,U)>] :: (Lazy.ByteString, Lazy.ByteString)
          [LclId, Str=DmdType]
          ds_s5K2 =
            case Data.ByteString.Lazy.$wsplitAt' 65536# wild_a5yn
            of _ [Occ=Dead] { (# ww3_a5KP, ww4_a5KQ #) ->
            (ww3_a5KP, ww4_a5KQ)
            } } in
        GHC.Types.:
          @ Strict.ByteString
          (case ds_s5K2 of _ [Occ=Dead] { (pre_X56W, suf_a56e) ->
           Data.ByteString.Internal.$fMonoidByteString_$cmconcat
             (Data.ByteString.Lazy.toChunks_go1 pre_X56W)
           })
          (case ds_s5K2 of _ [Occ=Dead] { (pre_X56q, suf_X570) ->
           rechunk suf_X570
           })
    }
end Rec }

-- RHS size: {terms: 2, types: 0, coercions: 0}
BloomFilter.Hash.doubleHash1 :: Word64
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
BloomFilter.Hash.doubleHash1 = GHC.Word.W64# 10471055255048590958##

-- RHS size: {terms: 59, types: 32, coercions: 2}
BloomFilter.Hash.$wdoubleHash [InlPrag=[0]]
  :: forall a_s693.
     Hashable a_s693 =>
     GHC.Prim.Int# -> a_s693 -> [Word32]
[GblId,
 Arity=3,
 Str=DmdType <L,1*C1(C1(U(U)))><S,U><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [60 0 0] 269 0}]
BloomFilter.Hash.$wdoubleHash =
  \ (@ a_s693)
    (w_s694 :: Hashable a_s693)
    (ww_s699 :: GHC.Prim.Int#)
    (w1_s696 :: a_s693) ->
    let {
      h_s5K0 [Dmd=<L,U(U)>] :: Word64
      [LclId, Str=DmdType]
      h_s5K0 =
        (w_s694
         `cast` (BloomFilter.Hash.N:Hashable[0] <a_s693>_N
                 :: (Hashable a_s693 :: Constraint)
                    ~R#
                    ((Salt -> a_s693 -> Word64) :: *)))
          BloomFilter.Hash.doubleHash1 w1_s696 } in
    let {
      h1_s5JZ [Dmd=<L,U(U)>] :: Word32
      [LclId, Str=DmdType]
      h1_s5JZ =
        case h_s5K0 of _ [Occ=Dead] { GHC.Word.W64# x#_a5Bt ->
        GHC.Word.W32#
          (GHC.Prim.and#
             (GHC.Prim.narrow32Word# (GHC.Prim.uncheckedShiftRL# x#_a5Bt 32#))
             4294967295##)
        } } in
    let {
      h2_s5JY [Dmd=<L,U(U)>] :: Word32
      [LclId, Str=DmdType]
      h2_s5JY =
        case h_s5K0 of _ [Occ=Dead] { GHC.Word.W64# x#_a5BS ->
        GHC.Word.W32# (GHC.Prim.narrow32Word# x#_a5BS)
        } } in
    letrec { -- READ: #aka let
      go_a5yR [Occ=LoopBreaker] :: [Word32] -> [Word32]
      [LclId, Arity=1, Str=DmdType <S,1*U>]
      go_a5yR = -- READ: compiled list comprehension
        \ (ds_a5yS :: [Word32]) ->
          case ds_a5yS of _ [Occ=Dead] {
            [] -> GHC.Types.[] @ Word32; -- READ: empty list case
            : y_a5yX ys_a5yY -> -- READ: #aka (x:xs)
              GHC.Types.: -- READ: cons infix
                @ Word32 -- READ: the type of the first operand
                (case h1_s5JZ of _ [Occ=Dead] { GHC.Word.W32# x#_a5CH ->
                 case h2_s5JY of _ [Occ=Dead] { GHC.Word.W32# x#1_a5Cx ->
                 case y_a5yX of _ [Occ=Dead] { GHC.Word.W32# y#_a5CB ->
                 GHC.Word.W32# -- apply W32 (unboxed) constr to get a W32
                   (GHC.Prim.narrow32Word#
                      (GHC.Prim.plusWord#
                         x#_a5CH
                         (GHC.Prim.narrow32Word# (GHC.Prim.timesWord# x#1_a5Cx y#_a5CB))))
                 }
                 }
                 })
                (go_a5yR ys_a5yY) -- READ: tail of the list
          }; } in
    go_a5yR -- READ: kick-off the loop
      (GHC.Word.$w$cenumFromTo1
         0## (GHC.Prim.narrow32Word# (GHC.Prim.int2Word# ww_s699)))

-- RHS size: {terms: 11, types: 9, coercions: 0}
doubleHash [InlPrag=INLINE[0]]
  :: forall a_a2BO. Hashable a_a2BO => Int -> a_a2BO -> [Word32]
[GblId,
 Arity=3,
 Str=DmdType <L,1*C1(C1(U(U)))><S(S),1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s693)
                 (w_s694 [Occ=Once] :: Hashable a_s693)
                 (w1_s695 [Occ=Once!] :: Int)
                 (w2_s696 [Occ=Once] :: a_s693) ->
                 case w1_s695 of _ [Occ=Dead] { GHC.Types.I# ww1_s699 [Occ=Once] ->
                 BloomFilter.Hash.$wdoubleHash @ a_s693 w_s694 ww1_s699 w2_s696
                 }}]
doubleHash =
  \ (@ a_s693)
    (w_s694 :: Hashable a_s693)
    (w1_s695 :: Int)
    (w2_s696 :: a_s693) ->
    case w1_s695 of _ [Occ=Dead] { GHC.Types.I# ww1_s699 ->
    BloomFilter.Hash.$wdoubleHash @ a_s693 w_s694 ww1_s699 w2_s696
    }

-- RHS size: {terms: 2, types: 0, coercions: 0}
BloomFilter.Hash.$trModule2 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
BloomFilter.Hash.$trModule2 = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
BloomFilter.Hash.$trModule1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 60 20}]
BloomFilter.Hash.$trModule1 = GHC.Types.TrNameS "BloomFilter.Hash"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
BloomFilter.Hash.$trModule :: GHC.Types.Module
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
BloomFilter.Hash.$trModule =
  GHC.Types.Module
    BloomFilter.Hash.$trModule2 BloomFilter.Hash.$trModule1

-- RHS size: {terms: 2, types: 0, coercions: 0}
BloomFilter.Hash.$tc'C:Hashable1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 20}]
BloomFilter.Hash.$tc'C:Hashable1 = GHC.Types.TrNameS "'C:Hashable"#

-- RHS size: {terms: 5, types: 0, coercions: 0}
BloomFilter.Hash.$tc'C:Hashable :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
BloomFilter.Hash.$tc'C:Hashable =
  GHC.Types.TyCon
    15350366277146155190##
    11892326176059284023##
    BloomFilter.Hash.$trModule
    BloomFilter.Hash.$tc'C:Hashable1

-- RHS size: {terms: 2, types: 0, coercions: 0}
BloomFilter.Hash.$tcHashable1 :: GHC.Types.TrName
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 20}]
BloomFilter.Hash.$tcHashable1 = GHC.Types.TrNameS "Hashable"#

-- RHS size: {terms: 5, types: 0, coercions: 0}
BloomFilter.Hash.$tcHashable :: GHC.Types.TyCon
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 50}]
BloomFilter.Hash.$tcHashable =
  GHC.Types.TyCon
    14368337847621322247##
    3169995627451274767##
    BloomFilter.Hash.$trModule
    BloomFilter.Hash.$tcHashable1

-- RHS size: {terms: 83, types: 98, coercions: 0}
BloomFilter.Hash.$w$shashStorable1 [InlPrag=[0]]
  :: GHC.Prim.Word# -> GHC.Prim.Double# -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 138 0}]
BloomFilter.Hash.$w$shashStorable1 =
  \ (ww_s69g :: GHC.Prim.Word#) (ww1_s69k :: GHC.Prim.Double#) ->
    case GHC.Magic.runRW#
           @ 'GHC.Types.PtrRepLifted
           @ Word64
           (\ (s_a5zo [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
              case GHC.Prim.noDuplicate# s_a5zo
              of s'_a5zp [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.newAlignedPinnedByteArray#
                     @ GHC.Prim.RealWorld 8# 8# s'_a5zp
              of _ [Occ=Dead] { (# ipv_a5Pn, ipv1_a5Po #) ->
              case GHC.Prim.unsafeFreezeByteArray#
                     @ GHC.Prim.RealWorld ipv1_a5Po ipv_a5Pn
              of _ [Occ=Dead] { (# ipv2_a5Pt, ipv3_a5Pu #) ->
              let {
                ptr_a5Ps [Dmd=<S,U>] :: GHC.Prim.Addr#
                [LclId, Str=DmdType]
                ptr_a5Ps = GHC.Prim.byteArrayContents# ipv3_a5Pu } in
              case GHC.Prim.writeDoubleOffAddr#
                     @ GHC.Prim.RealWorld ptr_a5Ps 0# ww1_s69k ipv2_a5Pt
              of s2_a5Qu [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.newAlignedPinnedByteArray#
                     @ GHC.Prim.RealWorld 8# 8# s2_a5Qu
              of _ [Occ=Dead] { (# ipv4_X5QL, ipv5_X5QN #) ->
              case GHC.Prim.unsafeFreezeByteArray#
                     @ GHC.Prim.RealWorld ipv5_X5QN ipv4_X5QL
              of _ [Occ=Dead] { (# ipv6_X5QV, ipv7_X5QX #) ->
              let {
                ptr1_X5Ss [Dmd=<S,U>] :: GHC.Prim.Addr#
                [LclId, Str=DmdType]
                ptr1_X5Ss = GHC.Prim.byteArrayContents# ipv7_X5QX } in
              case GHC.Prim.writeWord64OffAddr#
                     @ GHC.Prim.RealWorld ptr1_X5Ss 0# ww_s69g ipv6_X5QV
              of s1_a5PY [OS=OneShot] { __DEFAULT ->
              case {__pkg_ccall main hashword2 Addr#
                            -> Word#
                            -> Addr#
                            -> Addr#
                            -> State# RealWorld
                            -> (# State# RealWorld #)}_d5um
                     ptr_a5Ps 2## ptr1_X5Ss (GHC.Prim.plusAddr# ptr1_X5Ss 4#) s1_a5PY
              of _ [Occ=Dead] { (# ds_d5uk [OS=OneShot] #) ->
              case GHC.Prim.readWord64OffAddr#
                     @ GHC.Prim.RealWorld ptr1_X5Ss 0# ds_d5uk
              of _ [Occ=Dead] { (# ipv8_a5OI, ipv9_a5OJ #) ->
              case GHC.Prim.touch#
                     @ 'GHC.Types.PtrRepUnlifted
                     @ GHC.Prim.ByteArray#
                     ipv7_X5QX
                     ipv8_a5OI
              of s4_a5PH [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.touch#
                     @ 'GHC.Types.PtrRepUnlifted @ GHC.Prim.ByteArray# ipv3_a5Pu s4_a5PH
              of s3_X5RB [OS=OneShot] { __DEFAULT ->
              (# s3_X5RB, GHC.Word.W64# ipv9_a5OJ #)
              }
              }
              }
              }
              }
              }
              }
              }
              }
              }
              })
    of _ [Occ=Dead] { (# ipv_a5zs, ipv1_a5zt #) ->
    ipv1_a5zt
    }

-- RHS size: {terms: 11, types: 6, coercions: 0}
BloomFilter.Hash.$fHashableDouble_$shashStorable [InlPrag=INLINE[0]]
  :: Word64 -> Double -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s69c [Occ=Once!] :: Word64)
                 (w1_s69d [Occ=Once!] :: Double) ->
                 case w_s69c of _ [Occ=Dead] { GHC.Word.W64# ww1_s69g [Occ=Once] ->
                 case w1_s69d of _ [Occ=Dead] { GHC.Types.D# ww3_s69k [Occ=Once] ->
                 BloomFilter.Hash.$w$shashStorable1 ww1_s69g ww3_s69k
                 }
                 }}]
BloomFilter.Hash.$fHashableDouble_$shashStorable =
  \ (w_s69c :: Word64) (w1_s69d :: Double) ->
    case w_s69c of _ [Occ=Dead] { GHC.Word.W64# ww1_s69g ->
    case w1_s69d of _ [Occ=Dead] { GHC.Types.D# ww3_s69k ->
    BloomFilter.Hash.$w$shashStorable1 ww1_s69g ww3_s69k
    }
    }

-- RHS size: {terms: 83, types: 98, coercions: 0}
BloomFilter.Hash.$w$shashStorable [InlPrag=[0]]
  :: GHC.Prim.Word# -> GHC.Prim.Char# -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 138 0}]
BloomFilter.Hash.$w$shashStorable =
  \ (ww_s69r :: GHC.Prim.Word#) (ww1_s69v :: GHC.Prim.Char#) ->
    case GHC.Magic.runRW#
           @ 'GHC.Types.PtrRepLifted
           @ Word64
           (\ (s_a5zo [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
              case GHC.Prim.noDuplicate# s_a5zo
              of s'_a5zp [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.newAlignedPinnedByteArray#
                     @ GHC.Prim.RealWorld 4# 4# s'_a5zp
              of _ [Occ=Dead] { (# ipv_a5Pn, ipv1_a5Po #) ->
              case GHC.Prim.unsafeFreezeByteArray#
                     @ GHC.Prim.RealWorld ipv1_a5Po ipv_a5Pn
              of _ [Occ=Dead] { (# ipv2_a5Pt, ipv3_a5Pu #) ->
              let {
                ptr_a5Ps [Dmd=<S,U>] :: GHC.Prim.Addr#
                [LclId, Str=DmdType]
                ptr_a5Ps = GHC.Prim.byteArrayContents# ipv3_a5Pu } in
              case GHC.Prim.writeWideCharOffAddr#
                     @ GHC.Prim.RealWorld ptr_a5Ps 0# ww1_s69v ipv2_a5Pt
              of s2_a5QR [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.newAlignedPinnedByteArray#
                     @ GHC.Prim.RealWorld 8# 8# s2_a5QR
              of _ [Occ=Dead] { (# ipv4_X5QM, ipv5_X5QO #) ->
              case GHC.Prim.unsafeFreezeByteArray#
                     @ GHC.Prim.RealWorld ipv5_X5QO ipv4_X5QM
              of _ [Occ=Dead] { (# ipv6_X5QW, ipv7_X5QY #) ->
              let {
                ptr1_X5Su [Dmd=<S,U>] :: GHC.Prim.Addr#
                [LclId, Str=DmdType]
                ptr1_X5Su = GHC.Prim.byteArrayContents# ipv7_X5QY } in
              case GHC.Prim.writeWord64OffAddr#
                     @ GHC.Prim.RealWorld ptr1_X5Su 0# ww_s69r ipv6_X5QW
              of s1_a5PY [OS=OneShot] { __DEFAULT ->
              case {__pkg_ccall main hashword2 Addr#
                            -> Word#
                            -> Addr#
                            -> Addr#
                            -> State# RealWorld
                            -> (# State# RealWorld #)}_d5um
                     ptr_a5Ps 1## ptr1_X5Su (GHC.Prim.plusAddr# ptr1_X5Su 4#) s1_a5PY
              of _ [Occ=Dead] { (# ds_d5uk [OS=OneShot] #) ->
              case GHC.Prim.readWord64OffAddr#
                     @ GHC.Prim.RealWorld ptr1_X5Su 0# ds_d5uk
              of _ [Occ=Dead] { (# ipv8_a5OI, ipv9_a5OJ #) ->
              case GHC.Prim.touch#
                     @ 'GHC.Types.PtrRepUnlifted
                     @ GHC.Prim.ByteArray#
                     ipv7_X5QY
                     ipv8_a5OI
              of s4_a5PH [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.touch#
                     @ 'GHC.Types.PtrRepUnlifted @ GHC.Prim.ByteArray# ipv3_a5Pu s4_a5PH
              of s3_X5RC [OS=OneShot] { __DEFAULT ->
              (# s3_X5RC, GHC.Word.W64# ipv9_a5OJ #)
              }
              }
              }
              }
              }
              }
              }
              }
              }
              }
              })
    of _ [Occ=Dead] { (# ipv_a5zs, ipv1_a5zt #) ->
    ipv1_a5zt
    }

-- RHS size: {terms: 11, types: 6, coercions: 0}
BloomFilter.Hash.$fHashableChar_$shashStorable [InlPrag=INLINE[0]]
  :: Word64 -> Char -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s69n [Occ=Once!] :: Word64)
                 (w1_s69o [Occ=Once!] :: Char) ->
                 case w_s69n of _ [Occ=Dead] { GHC.Word.W64# ww1_s69r [Occ=Once] ->
                 case w1_s69o of _ [Occ=Dead] { GHC.Types.C# ww3_s69v [Occ=Once] ->
                 BloomFilter.Hash.$w$shashStorable ww1_s69r ww3_s69v
                 }
                 }}]
BloomFilter.Hash.$fHashableChar_$shashStorable =
  \ (w_s69n :: Word64) (w1_s69o :: Char) ->
    case w_s69n of _ [Occ=Dead] { GHC.Word.W64# ww1_s69r ->
    case w1_s69o of _ [Occ=Dead] { GHC.Types.C# ww3_s69v ->
    BloomFilter.Hash.$w$shashStorable ww1_s69r ww3_s69v
    }
    }

-- RHS size: {terms: 83, types: 98, coercions: 0}
BloomFilter.Hash.$w$shashStorable2 [InlPrag=[0]]
  :: GHC.Prim.Word# -> GHC.Prim.Int# -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 138 0}]
BloomFilter.Hash.$w$shashStorable2 =
  \ (ww_s69C :: GHC.Prim.Word#) (ww1_s69G :: GHC.Prim.Int#) ->
    case GHC.Magic.runRW#
           @ 'GHC.Types.PtrRepLifted
           @ Word64
           (\ (s_a5zo [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
              case GHC.Prim.noDuplicate# s_a5zo
              of s'_a5zp [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.newAlignedPinnedByteArray#
                     @ GHC.Prim.RealWorld 8# 8# s'_a5zp
              of _ [Occ=Dead] { (# ipv_a5Pn, ipv1_a5Po #) ->
              case GHC.Prim.unsafeFreezeByteArray#
                     @ GHC.Prim.RealWorld ipv1_a5Po ipv_a5Pn
              of _ [Occ=Dead] { (# ipv2_a5Pt, ipv3_a5Pu #) ->
              let {
                ptr_a5Ps [Dmd=<S,U>] :: GHC.Prim.Addr#
                [LclId, Str=DmdType]
                ptr_a5Ps = GHC.Prim.byteArrayContents# ipv3_a5Pu } in
              case GHC.Prim.writeIntOffAddr#
                     @ GHC.Prim.RealWorld ptr_a5Ps 0# ww1_s69G ipv2_a5Pt
              of s2_a5Rd [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.newAlignedPinnedByteArray#
                     @ GHC.Prim.RealWorld 8# 8# s2_a5Rd
              of _ [Occ=Dead] { (# ipv4_X5QN, ipv5_X5QP #) ->
              case GHC.Prim.unsafeFreezeByteArray#
                     @ GHC.Prim.RealWorld ipv5_X5QP ipv4_X5QN
              of _ [Occ=Dead] { (# ipv6_X5QX, ipv7_X5QZ #) ->
              let {
                ptr1_X5Sw [Dmd=<S,U>] :: GHC.Prim.Addr#
                [LclId, Str=DmdType]
                ptr1_X5Sw = GHC.Prim.byteArrayContents# ipv7_X5QZ } in
              case GHC.Prim.writeWord64OffAddr#
                     @ GHC.Prim.RealWorld ptr1_X5Sw 0# ww_s69C ipv6_X5QX
              of s1_a5PY [OS=OneShot] { __DEFAULT ->
              case {__pkg_ccall main hashword2 Addr#
                            -> Word#
                            -> Addr#
                            -> Addr#
                            -> State# RealWorld
                            -> (# State# RealWorld #)}_d5um
                     ptr_a5Ps 2## ptr1_X5Sw (GHC.Prim.plusAddr# ptr1_X5Sw 4#) s1_a5PY
              of _ [Occ=Dead] { (# ds_d5uk [OS=OneShot] #) ->
              case GHC.Prim.readWord64OffAddr#
                     @ GHC.Prim.RealWorld ptr1_X5Sw 0# ds_d5uk
              of _ [Occ=Dead] { (# ipv8_a5OI, ipv9_a5OJ #) ->
              case GHC.Prim.touch#
                     @ 'GHC.Types.PtrRepUnlifted
                     @ GHC.Prim.ByteArray#
                     ipv7_X5QZ
                     ipv8_a5OI
              of s4_a5PH [OS=OneShot] { __DEFAULT ->
              case GHC.Prim.touch#
                     @ 'GHC.Types.PtrRepUnlifted @ GHC.Prim.ByteArray# ipv3_a5Pu s4_a5PH
              of s3_X5RD [OS=OneShot] { __DEFAULT ->
              (# s3_X5RD, GHC.Word.W64# ipv9_a5OJ #)
              }
              }
              }
              }
              }
              }
              }
              }
              }
              }
              })
    of _ [Occ=Dead] { (# ipv_a5zs, ipv1_a5zt #) ->
    ipv1_a5zt
    }

-- RHS size: {terms: 11, types: 6, coercions: 0}
BloomFilter.Hash.$fHashableInt_$shashStorable [InlPrag=INLINE[0]]
  :: Word64 -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s69y [Occ=Once!] :: Word64)
                 (w1_s69z [Occ=Once!] :: Int) ->
                 case w_s69y of _ [Occ=Dead] { GHC.Word.W64# ww1_s69C [Occ=Once] ->
                 case w1_s69z of _ [Occ=Dead] { GHC.Types.I# ww3_s69G [Occ=Once] ->
                 BloomFilter.Hash.$w$shashStorable2 ww1_s69C ww3_s69G
                 }
                 }}]
BloomFilter.Hash.$fHashableInt_$shashStorable =
  \ (w_s69y :: Word64) (w1_s69z :: Int) ->
    case w_s69y of _ [Occ=Dead] { GHC.Word.W64# ww1_s69C ->
    case w1_s69z of _ [Occ=Dead] { GHC.Types.I# ww3_s69G ->
    BloomFilter.Hash.$w$shashStorable2 ww1_s69C ww3_s69G
    }
    }

-- RHS size: {terms: 1, types: 0, coercions: 0}
BloomFilter.Hash.$fHashableDouble_$chashSalt
  :: Salt -> Double -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashableDouble_$shashStorable}]
BloomFilter.Hash.$fHashableDouble_$chashSalt =
  BloomFilter.Hash.$fHashableDouble_$shashStorable

-- RHS size: {terms: 1, types: 0, coercions: 3}
BloomFilter.Hash.$fHashableDouble [InlPrag=INLINE (sat-args=0)]
  :: Hashable Double
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashableDouble_$chashSalt
               `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Double>_N)
                       :: ((Salt -> Double -> Word64) :: *)
                          ~R#
                          (Hashable Double :: Constraint))}]
BloomFilter.Hash.$fHashableDouble =
  BloomFilter.Hash.$fHashableDouble_$shashStorable
  `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Double>_N)
          :: ((Salt -> Double -> Word64) :: *)
             ~R#
             (Hashable Double :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0}
BloomFilter.Hash.$fHashableInt_$chashSalt :: Salt -> Int -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashableInt_$shashStorable}]
BloomFilter.Hash.$fHashableInt_$chashSalt =
  BloomFilter.Hash.$fHashableInt_$shashStorable

-- RHS size: {terms: 1, types: 0, coercions: 3}
BloomFilter.Hash.$fHashableInt [InlPrag=INLINE (sat-args=0)]
  :: Hashable Int
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashableInt_$chashSalt
               `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Int>_N)
                       :: ((Salt -> Int -> Word64) :: *)
                          ~R#
                          (Hashable Int :: Constraint))}]
BloomFilter.Hash.$fHashableInt =
  BloomFilter.Hash.$fHashableInt_$shashStorable
  `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Int>_N)
          :: ((Salt -> Int -> Word64) :: *) ~R# (Hashable Int :: Constraint))

-- RHS size: {terms: 1, types: 0, coercions: 0}
BloomFilter.Hash.$fHashableChar_$chashSalt
  :: Salt -> Char -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashableChar_$shashStorable}]
BloomFilter.Hash.$fHashableChar_$chashSalt =
  BloomFilter.Hash.$fHashableChar_$shashStorable

-- RHS size: {terms: 1, types: 0, coercions: 3}
BloomFilter.Hash.$fHashableChar [InlPrag=INLINE (sat-args=0)]
  :: Hashable Char
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <S(S),1*U(U)><S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashableChar_$chashSalt
               `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Char>_N)
                       :: ((Salt -> Char -> Word64) :: *)
                          ~R#
                          (Hashable Char :: Constraint))}]
BloomFilter.Hash.$fHashableChar =
  BloomFilter.Hash.$fHashableChar_$shashStorable
  `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Char>_N)
          :: ((Salt -> Char -> Word64) :: *)
             ~R#
             (Hashable Char :: Constraint))

-- RHS size: {terms: 2, types: 0, coercions: 0}
BloomFilter.Hash.$fHashable[]1 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=DmdType m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
BloomFilter.Hash.$fHashable[]1 = GHC.Types.I# 0#

-- RHS size: {terms: 142, types: 138, coercions: 15}
BloomFilter.Hash.$fHashable[]_$chashSalt
  :: forall a_a5rO. Storable a_a5rO => Salt -> [a_a5rO] -> Word64
[GblId,
 Arity=3,
 Str=DmdType <L,U(C(U(U)),C(U(U)),A,C(C1(C1(C1(U(U,A))))),A,A,A,A)><L,U(U)><L,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [30 20 30] 476 0}]
BloomFilter.Hash.$fHashable[]_$chashSalt =
  \ (@ a_a5rO)
    ($dStorable_a5rP :: Storable a_a5rO)
    (salt_a4tV :: Salt)
    (xs_a4tW :: [a_a5rO]) ->
    case GHC.Magic.runRW#
           @ 'GHC.Types.PtrRepLifted
           @ Word64
           (\ (s_a5zo [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
              case GHC.Prim.noDuplicate# s_a5zo
              of s'_a5zp [OS=OneShot] { __DEFAULT ->
              let {
                sizex_s5JM [Dmd=<L,U(U)>] :: Int
                [LclId, Str=DmdType]
                sizex_s5JM =
                  case xs_a4tW of _ [Occ=Dead] {
                    [] -> BloomFilter.Hash.$fHashable[]1;
                    : ds1_a5Rn ds2_a5Ro -> sizeOf @ a_a5rO $dStorable_a5rP ds1_a5Rn
                  } } in
              let {
                len_a5zA [Dmd=<L,U(U)>] :: Int
                [LclId, Str=DmdType]
                len_a5zA =
                  case GHC.List.$wlenAcc @ a_a5rO xs_a4tW 0#
                  of ww2_a5zC { __DEFAULT ->
                  GHC.Types.I# ww2_a5zC
                  } } in
              ((Foreign.Marshal.Array.allocaArray
                  @ a_a5rO
                  @ Word64
                  $dStorable_a5rP
                  len_a5zA
                  ((\ (ptr_a5zG :: Ptr a_a5rO)
                      (eta_a5zH [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                      case Foreign.Marshal.Array.newArray2
                             @ a_a5rO $dStorable_a5rP ptr_a5zG xs_a4tW eta_a5zH
                      of _ [Occ=Dead] { (# ipv_a5zM, ipv1_a5zN #) ->
                      case GHC.Prim.newAlignedPinnedByteArray#
                             @ GHC.Prim.RealWorld 8# 8# ipv_a5zM
                      of _ [Occ=Dead] { (# ipv2_a5Pn, ipv3_a5Po #) ->
                      case GHC.Prim.unsafeFreezeByteArray#
                             @ GHC.Prim.RealWorld ipv3_a5Po ipv2_a5Pn
                      of _ [Occ=Dead] { (# ipv4_a5Pt, ipv5_a5Pu #) ->
                      case salt_a4tV of _ [Occ=Dead] { GHC.Word.W64# x_a5PW ->
                      let {
                        ptr1_a5Ps [Dmd=<S,U>] :: GHC.Prim.Addr#
                        [LclId, Str=DmdType]
                        ptr1_a5Ps = GHC.Prim.byteArrayContents# ipv5_a5Pu } in
                      case GHC.Prim.writeWord64OffAddr#
                             @ GHC.Prim.RealWorld ptr1_a5Ps 0# x_a5PW ipv4_a5Pt
                      of s2_a5PY [OS=OneShot] { __DEFAULT ->
                      case len_a5zA of _ [Occ=Dead] { GHC.Types.I# x1_a5HX ->
                      case sizex_s5JM of _ [Occ=Dead] { GHC.Types.I# y_a5I1 ->
                      let {
                        x#_a5NT [Dmd=<S,U>] :: GHC.Prim.Word#
                        [LclId, Str=DmdType]
                        x#_a5NT = GHC.Prim.int2Word# (GHC.Prim.*# x1_a5HX y_a5I1) } in
                      case GHC.Prim.and# x#_a5NT 3## of _ [Occ=Dead] {
                        __DEFAULT ->
                          case ptr_a5zG of _ [Occ=Dead] { GHC.Ptr.Ptr ds4_d5tX ->
                          case {__pkg_ccall main hashlittle2 Addr#
                              -> Word#
                              -> Addr#
                              -> Addr#
                              -> State# RealWorld
                              -> (# State# RealWorld #)}_d5u6
                                 ds4_d5tX
                                 x#_a5NT
                                 ptr1_a5Ps
                                 (GHC.Prim.plusAddr# ptr1_a5Ps 4#)
                                 s2_a5PY
                          of _ [Occ=Dead] { (# ds5_d5u4 [OS=OneShot] #) ->
                          case GHC.Prim.readWord64OffAddr#
                                 @ GHC.Prim.RealWorld ptr1_a5Ps 0# ds5_d5u4
                          of _ [Occ=Dead] { (# ipv6_a5OI, ipv7_a5OJ #) ->
                          case GHC.Prim.touch#
                                 @ 'GHC.Types.PtrRepUnlifted
                                 @ GHC.Prim.ByteArray#
                                 ipv5_a5Pu
                                 ipv6_a5OI
                          of s4_a5PH [OS=OneShot] { __DEFAULT ->
                          (# s4_a5PH, GHC.Word.W64# ipv7_a5OJ #)
                          }
                          }
                          }
                          };
                        0## ->
                          case ptr_a5zG
                               `cast` ((Ptr U(phant:<*>_N, a_a5rO, Word32)_P)_R
                                       :: (Ptr a_a5rO :: *) ~R# (Ptr Word32 :: *))
                          of _ [Occ=Dead] { GHC.Ptr.Ptr ds4_d5ud ->
                          case {__pkg_ccall main hashword2 Addr#
                            -> Word#
                            -> Addr#
                            -> Addr#
                            -> State# RealWorld
                            -> (# State# RealWorld #)}_d5um
                                 ds4_d5ud
                                 (GHC.Prim.quotWord# x#_a5NT 4##)
                                 ptr1_a5Ps
                                 (GHC.Prim.plusAddr# ptr1_a5Ps 4#)
                                 s2_a5PY
                          of _ [Occ=Dead] { (# ds5_d5uk [OS=OneShot] #) ->
                          case GHC.Prim.readWord64OffAddr#
                                 @ GHC.Prim.RealWorld ptr1_a5Ps 0# ds5_d5uk
                          of _ [Occ=Dead] { (# ipv6_a5OI, ipv7_a5OJ #) ->
                          case GHC.Prim.touch#
                                 @ 'GHC.Types.PtrRepUnlifted
                                 @ GHC.Prim.ByteArray#
                                 ipv5_a5Pu
                                 ipv6_a5OI
                          of s4_a5PH [OS=OneShot] { __DEFAULT ->
                          (# s4_a5PH, GHC.Word.W64# ipv7_a5OJ #)
                          }
                          }
                          }
                          }
                      }
                      }
                      }
                      }
                      }
                      }
                      }
                      })
                   `cast` (<Ptr a_a5rO>_R -> Sym (GHC.Types.N:IO[0] <Word64>_R)
                           :: ((Ptr a_a5rO
                                -> GHC.Prim.State# GHC.Prim.RealWorld
                                -> (# GHC.Prim.State# GHC.Prim.RealWorld, Word64 #)) :: *)
                              ~R#
                              ((Ptr a_a5rO -> IO Word64) :: *))))
               `cast` (GHC.Types.N:IO[0] <Word64>_R
                       :: (IO Word64 :: *)
                          ~R#
                          ((GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, Word64 #)) :: *)))
                s'_a5zp
              })
    of _ [Occ=Dead] { (# ipv_a5zs, ipv1_a5zt #) ->
    ipv1_a5zt
    }

-- RHS size: {terms: 1, types: 0, coercions: 10}
BloomFilter.Hash.$fHashable[] [InlPrag=INLINE (sat-args=0)]
  :: forall a_a4Bf. Storable a_a4Bf => Hashable [a_a4Bf]
[GblId[DFunId(nt)],
 Arity=3,
 Str=DmdType <L,U(C(U(U)),C(U(U)),A,C(C1(C1(C1(U(U,A))))),A,A,A,A)><L,U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashable[]_$chashSalt
               `cast` (forall (a_a5rO :: <*>_N).
                       <Storable a_a5rO>_R
                       -> Sym (BloomFilter.Hash.N:Hashable[0] <[a_a5rO]>_N)
                       :: ((forall a_a5rO.
                            Storable a_a5rO =>
                            Salt -> [a_a5rO] -> Word64) :: *)
                          ~R#
                          ((forall a_a5rO. Storable a_a5rO => Hashable [a_a5rO]) :: *))}]
BloomFilter.Hash.$fHashable[] =
  BloomFilter.Hash.$fHashable[]_$chashSalt
  `cast` (forall (a_a5rO :: <*>_N).
          <Storable a_a5rO>_R
          -> Sym (BloomFilter.Hash.N:Hashable[0] <[a_a5rO]>_N)
          :: ((forall a_a5rO.
               Storable a_a5rO =>
               Salt -> [a_a5rO] -> Word64) :: *)
             ~R#
             ((forall a_a5rO. Storable a_a5rO => Hashable [a_a5rO]) :: *))

-- RHS size: {terms: 145, types: 138, coercions: 0}
BloomFilter.Hash.$whashByteString [InlPrag=[0]]
  :: Word64
     -> GHC.Prim.Addr#
     -> GHC.ForeignPtr.ForeignPtrContents
     -> GHC.Prim.Int#
     -> GHC.Prim.Int#
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Word64 #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=DmdType <L,1*U(U)><S,U><L,U><S,U><S,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 0 0 0 0] 232 60}]
BloomFilter.Hash.$whashByteString =
  \ (w_s69N :: Word64)
    (ww_s69S :: GHC.Prim.Addr#)
    (ww1_s69T :: GHC.ForeignPtr.ForeignPtrContents)
    (ww2_s69U :: GHC.Prim.Int#)
    (ww3_s69V :: GHC.Prim.Int#)
    (w1_s69P [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    case GHC.Prim.newPinnedByteArray#
           @ GHC.Prim.RealWorld (GHC.Prim.+# ww3_s69V 1#) w1_s69P
    of _ [Occ=Dead] { (# ipv_a63b, ipv1_a63c #) ->
    case GHC.Prim.unsafeFreezeByteArray#
           @ GHC.Prim.RealWorld ipv1_a63c ipv_a63b
    of _ [Occ=Dead] { (# ipv2_a63h, ipv3_a63i #) ->
    let {
      buf_a63g [Dmd=<S,U>] :: GHC.Prim.Addr#
      [LclId, Str=DmdType]
      buf_a63g = GHC.Prim.byteArrayContents# ipv3_a63i } in
    case {__pkg_ccall bytestring-0.10.8.1 memcpy Addr#
                                        -> Addr#
                                        -> Word#
                                        -> State# RealWorld
                                        -> (# State# RealWorld, Addr# #)}_a63k
           buf_a63g
           (GHC.Prim.plusAddr# ww_s69S ww2_s69U)
           (GHC.Prim.int2Word# ww3_s69V)
           ipv2_a63h
    of _ [Occ=Dead] { (# ds4_a63n, ds5_a63o #) ->
    case GHC.Prim.writeWord8OffAddr#
           @ GHC.Prim.RealWorld
           (GHC.Prim.plusAddr# buf_a63g ww3_s69V)
           0#
           0##
           ds4_a63n
    of s2_a63q [OS=OneShot] { __DEFAULT ->
    case GHC.Prim.newAlignedPinnedByteArray#
           @ GHC.Prim.RealWorld 8# 8# s2_a63q
    of _ [Occ=Dead] { (# ipv4_a5Pn, ipv5_a5Po #) ->
    case GHC.Prim.unsafeFreezeByteArray#
           @ GHC.Prim.RealWorld ipv5_a5Po ipv4_a5Pn
    of _ [Occ=Dead] { (# ipv6_a5Pt, ipv7_a5Pu #) ->
    case w_s69N of _ [Occ=Dead] { GHC.Word.W64# x_a5PW ->
    let {
      ptr_a5Ps [Dmd=<S,U>] :: GHC.Prim.Addr#
      [LclId, Str=DmdType]
      ptr_a5Ps = GHC.Prim.byteArrayContents# ipv7_a5Pu } in
    case GHC.Prim.writeWord64OffAddr#
           @ GHC.Prim.RealWorld ptr_a5Ps 0# x_a5PW ipv6_a5Pt
    of s1_a5PY [OS=OneShot] { __DEFAULT ->
    let {
      x#_a5NT [Dmd=<S,U>] :: GHC.Prim.Word#
      [LclId, Str=DmdType]
      x#_a5NT = GHC.Prim.int2Word# ww3_s69V } in
    case GHC.Prim.and# x#_a5NT 3## of _ [Occ=Dead] {
      __DEFAULT ->
        case {__pkg_ccall main hashlittle2 Addr#
                              -> Word#
                              -> Addr#
                              -> Addr#
                              -> State# RealWorld
                              -> (# State# RealWorld #)}_d5u6
               buf_a63g x#_a5NT ptr_a5Ps (GHC.Prim.plusAddr# ptr_a5Ps 4#) s1_a5PY
        of _ [Occ=Dead] { (# ds_d5u4 [OS=OneShot] #) ->
        case GHC.Prim.readWord64OffAddr#
               @ GHC.Prim.RealWorld ptr_a5Ps 0# ds_d5u4
        of _ [Occ=Dead] { (# ipv8_a5OI, ipv9_a5OJ #) ->
        case GHC.Prim.touch#
               @ 'GHC.Types.PtrRepUnlifted
               @ GHC.Prim.ByteArray#
               ipv7_a5Pu
               ipv8_a5OI
        of s4_a5PH [OS=OneShot] { __DEFAULT ->
        case GHC.Prim.touch#
               @ 'GHC.Types.PtrRepLifted
               @ GHC.ForeignPtr.ForeignPtrContents
               ww1_s69T
               s4_a5PH
        of s'_a63w [OS=OneShot] { __DEFAULT ->
        case GHC.Prim.touch#
               @ 'GHC.Types.PtrRepUnlifted @ GHC.Prim.ByteArray# ipv3_a63i s'_a63w
        of s3_a63x [OS=OneShot] { __DEFAULT ->
        (# s3_a63x, GHC.Word.W64# ipv9_a5OJ #)
        }
        }
        }
        }
        };
      0## ->
        case {__pkg_ccall main hashword2 Addr#
                            -> Word#
                            -> Addr#
                            -> Addr#
                            -> State# RealWorld
                            -> (# State# RealWorld #)}_d5um
               buf_a63g
               (GHC.Prim.quotWord# x#_a5NT 4##)
               ptr_a5Ps
               (GHC.Prim.plusAddr# ptr_a5Ps 4#)
               s1_a5PY
        of _ [Occ=Dead] { (# ds_d5uk [OS=OneShot] #) ->
        case GHC.Prim.readWord64OffAddr#
               @ GHC.Prim.RealWorld ptr_a5Ps 0# ds_d5uk
        of _ [Occ=Dead] { (# ipv8_a5OI, ipv9_a5OJ #) ->
        case GHC.Prim.touch#
               @ 'GHC.Types.PtrRepUnlifted
               @ GHC.Prim.ByteArray#
               ipv7_a5Pu
               ipv8_a5OI
        of s4_a5PH [OS=OneShot] { __DEFAULT ->
        case GHC.Prim.touch#
               @ 'GHC.Types.PtrRepLifted
               @ GHC.ForeignPtr.ForeignPtrContents
               ww1_s69T
               s4_a5PH
        of s'_a63w [OS=OneShot] { __DEFAULT ->
        case GHC.Prim.touch#
               @ 'GHC.Types.PtrRepUnlifted @ GHC.Prim.ByteArray# ipv3_a63i s'_a63w
        of s3_a63x [OS=OneShot] { __DEFAULT ->
        (# s3_a63x, GHC.Word.W64# ipv9_a5OJ #)
        }
        }
        }
        }
        }
    }
    }
    }
    }
    }
    }
    }
    }
    }

-- RHS size: {terms: 13, types: 9, coercions: 0}
BloomFilter.Hash.$fHashableByteString1 [InlPrag=INLINE[0]]
  :: Word64
     -> Strict.ByteString
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Word64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType <L,1*U(U)><S(SLSS),1*U(U,U,U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s69N [Occ=Once] :: Word64)
                 (w1_s69O [Occ=Once!] :: Strict.ByteString)
                 (w2_s69P [Occ=Once, OS=OneShot]
                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w1_s69O
                 of _ [Occ=Dead]
                 { Data.ByteString.Internal.PS ww1_s69S [Occ=Once]
                                               ww2_s69T [Occ=Once] ww3_s69U [Occ=Once]
                                               ww4_s69V [Occ=Once] ->
                 BloomFilter.Hash.$whashByteString
                   w_s69N ww1_s69S ww2_s69T ww3_s69U ww4_s69V w2_s69P
                 }}]
BloomFilter.Hash.$fHashableByteString1 =
  \ (w_s69N :: Word64)
    (w1_s69O :: Strict.ByteString)
    (w2_s69P [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    case w1_s69O
    of _ [Occ=Dead]
    { Data.ByteString.Internal.PS ww1_s69S ww2_s69T ww3_s69U
                                  ww4_s69V ->
    BloomFilter.Hash.$whashByteString
      w_s69N ww1_s69S ww2_s69T ww3_s69U ww4_s69V w2_s69P
    }

Rec {
-- RHS size: {terms: 26, types: 29, coercions: 0}
BloomFilter.Hash.$fHashableByteString_go [Occ=LoopBreaker]
  :: [Strict.ByteString]
     -> Word64
     -> GHC.Prim.State# GHC.Prim.RealWorld
     -> (# GHC.Prim.State# GHC.Prim.RealWorld, Word64 #)
[GblId, Arity=3, Caf=NoCafRefs, Str=DmdType <S,1*U><L,U(U)><S,U>]
BloomFilter.Hash.$fHashableByteString_go =
  \ (ds_a5ST :: [Strict.ByteString])
    (eta1_a5SU :: Word64)
    (eta2_a5SV [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
    case ds_a5ST of _ [Occ=Dead] {
      [] -> (# eta2_a5SV, eta1_a5SU #);
      : y_a5T0 ys_a5T1 ->
        case y_a5T0
        of _ [Occ=Dead]
        { Data.ByteString.Internal.PS ww1_s69S ww2_s69T ww3_s69U
                                      ww4_s69V ->
        case BloomFilter.Hash.$whashByteString
               eta1_a5SU ww1_s69S ww2_s69T ww3_s69U ww4_s69V eta2_a5SV
        of _ [Occ=Dead] { (# ipv_a5T5, ipv1_a5T6 #) ->
        BloomFilter.Hash.$fHashableByteString_go ys_a5T1 ipv1_a5T6 ipv_a5T5
        }
        }
    }
end Rec }

-- RHS size: {terms: 16, types: 17, coercions: 0}
BloomFilter.Hash.$fHashableByteString_$chashSalt
  :: Salt -> Lazy.ByteString -> Word64
[GblId,
 Arity=2,
 Str=DmdType <L,U(U)><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 92 0}]
BloomFilter.Hash.$fHashableByteString_$chashSalt =
  \ (salt_a4tE :: Salt) (bs_a4tF :: Lazy.ByteString) ->
    case GHC.Magic.runRW#
           @ 'GHC.Types.PtrRepLifted
           @ Word64
           (\ (s_a5zo [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
              case GHC.Prim.noDuplicate# s_a5zo
              of s'_a5zp [OS=OneShot] { __DEFAULT ->
              BloomFilter.Hash.$fHashableByteString_go
                (rechunk bs_a4tF) salt_a4tE s'_a5zp
              })
    of _ [Occ=Dead] { (# ipv_a5zs, ipv1_a5zt #) ->
    ipv1_a5zt
    }

-- RHS size: {terms: 1, types: 0, coercions: 3}
BloomFilter.Hash.$fHashableByteString [InlPrag=INLINE (sat-args=0)]
  :: Hashable Lazy.ByteString
[GblId[DFunId(nt)],
 Arity=2,
 Str=DmdType <L,U(U)><S,1*U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashableByteString_$chashSalt
               `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Lazy.ByteString>_N)
                       :: ((Salt -> Lazy.ByteString -> Word64) :: *)
                          ~R#
                          (Hashable Lazy.ByteString :: Constraint))}]
BloomFilter.Hash.$fHashableByteString =
  BloomFilter.Hash.$fHashableByteString_$chashSalt
  `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Lazy.ByteString>_N)
          :: ((Salt -> Lazy.ByteString -> Word64) :: *)
             ~R#
             (Hashable Lazy.ByteString :: Constraint))

-- RHS size: {terms: 21, types: 22, coercions: 0}
BloomFilter.Hash.$fHashableByteString0_$chashSalt
  :: Salt -> Strict.ByteString -> Word64
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <L,1*U(U)><S(SLSS),1*U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (salt_a4tG [Occ=Once] :: Salt)
                 (bs_a4tH [Occ=Once] :: Strict.ByteString) ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ Word64
                        (\ (s_a5zo [Occ=Once, OS=OneShot]
                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           case GHC.Prim.noDuplicate# s_a5zo
                           of s'_a5zp [OS=OneShot] { __DEFAULT ->
                           BloomFilter.Hash.$fHashableByteString1 salt_a4tG bs_a4tH s'_a5zp
                           })
                 of _ [Occ=Dead] { (# _ [Occ=Dead], ipv1_a5zt [Occ=Once] #) ->
                 ipv1_a5zt
                 }}]
BloomFilter.Hash.$fHashableByteString0_$chashSalt =
  \ (salt_a4tG :: Salt) (bs_a4tH :: Strict.ByteString) ->
    case GHC.Magic.runRW#
           @ 'GHC.Types.PtrRepLifted
           @ Word64
           (\ (s_a5zo [OS=OneShot] :: GHC.Prim.State# GHC.Prim.RealWorld) ->
              case GHC.Prim.noDuplicate# s_a5zo
              of s'_a5zp [OS=OneShot] { __DEFAULT ->
              case bs_a4tH
              of _ [Occ=Dead]
              { Data.ByteString.Internal.PS ww1_s69S ww2_s69T ww3_s69U
                                            ww4_s69V ->
              BloomFilter.Hash.$whashByteString
                salt_a4tG ww1_s69S ww2_s69T ww3_s69U ww4_s69V s'_a5zp
              }
              })
    of _ [Occ=Dead] { (# ipv_a5zs, ipv1_a5zt #) ->
    ipv1_a5zt
    }

-- RHS size: {terms: 1, types: 0, coercions: 3}
BloomFilter.Hash.$fHashableByteString0 [InlPrag=INLINE (sat-args=0)]
  :: Hashable Strict.ByteString
[GblId[DFunId(nt)],
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <L,1*U(U)><S(SLSS),1*U(U,U,U,U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=False,boring_ok=True)
         Tmpl= BloomFilter.Hash.$fHashableByteString0_$chashSalt
               `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Strict.ByteString>_N)
                       :: ((Salt -> Strict.ByteString -> Word64) :: *)
                          ~R#
                          (Hashable Strict.ByteString :: Constraint))}]
BloomFilter.Hash.$fHashableByteString0 =
  BloomFilter.Hash.$fHashableByteString0_$chashSalt
  `cast` (Sym (BloomFilter.Hash.N:Hashable[0] <Strict.ByteString>_N)
          :: ((Salt -> Strict.ByteString -> Word64) :: *)
             ~R#
             (Hashable Strict.ByteString :: Constraint))
